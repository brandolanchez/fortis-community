{"version":3,"sources":["../src/audio.ts"],"sourcesContent":["/**\n * @snapie/composer/audio - Audio Upload Module\n * \n * Optional module for 3Speak audio upload integration.\n * Only import this if you need audio upload functionality.\n * \n * @example\n * ```typescript\n * import { uploadAudioTo3Speak } from '@snapie/composer/audio';\n * \n * const embedUrl = await uploadAudioTo3Speak(audioBlob, {\n *   apiKey: '...',\n *   owner: 'username',\n *   onProgress: (progress) => console.log(progress)\n * });\n * ```\n */\n\n/**\n * Audio upload progress callback\n */\nexport type AudioProgressCallback = (\n    progress: number,\n    status: 'uploading' | 'processing' | 'complete' | 'error'\n) => void;\n\n/**\n * Options for audio upload\n */\nexport interface AudioUploadOptions {\n    /** 3Speak API key */\n    apiKey: string;\n    /** Hive username of the uploader */\n    owner: string;\n    /** App name for metadata (default: \"snapie\") */\n    appName?: string;\n    /** Progress callback */\n    onProgress?: AudioProgressCallback;\n}\n\n/**\n * Audio upload result\n */\nexport interface AudioUploadResult {\n    /** The play URL to include in posts */\n    playUrl: string;\n    /** The audio ID */\n    audioId: string;\n}\n\n/**\n * Upload audio to 3Speak using TUS protocol\n * \n * @param file - Audio file or blob to upload\n * @param options - Upload options\n * @returns Promise resolving to play URL\n */\nexport async function uploadAudioTo3Speak(\n    file: File | Blob,\n    options: AudioUploadOptions\n): Promise<AudioUploadResult> {\n    // Dynamic import to avoid bundling tus-js-client when not needed\n    const tus = await import('tus-js-client');\n    \n    // Convert Blob to File if needed\n    const audioFile = file instanceof File \n        ? file \n        : new File([file], `audio-${Date.now()}.webm`, { type: file.type });\n    \n    return new Promise((resolve, reject) => {\n        let playUrl: string | null = null;\n        \n        const upload = new tus.Upload(audioFile, {\n            endpoint: 'https://audio.3speak.tv/uploads',\n            retryDelays: [0, 3000, 5000, 10000, 20000],\n            metadata: {\n                filename: audioFile.name,\n                owner: options.owner,\n                frontend_app: options.appName ?? 'snapie',\n                filetype: audioFile.type || 'audio/webm'\n            },\n            headers: {\n                'X-API-Key': options.apiKey\n            },\n            onError: (error) => {\n                options.onProgress?.(0, 'error');\n                reject(error);\n            },\n            onProgress: (bytesUploaded, bytesTotal) => {\n                const percentage = (bytesUploaded / bytesTotal) * 100;\n                options.onProgress?.(Math.round(percentage), 'uploading');\n            },\n            onAfterResponse: (req, res) => {\n                const url = res.getHeader('X-Play-URL');\n                if (url) {\n                    playUrl = url;\n                }\n            },\n            onSuccess: () => {\n                if (playUrl) {\n                    options.onProgress?.(100, 'complete');\n                    const audioId = extractAudioIdFromPlayUrl(playUrl);\n                    resolve({\n                        playUrl,\n                        audioId: audioId ?? ''\n                    });\n                } else {\n                    options.onProgress?.(0, 'error');\n                    reject(new Error('Failed to get play URL from server'));\n                }\n            }\n        });\n        \n        upload.start();\n    });\n}\n\n/**\n * Extract audio ID from 3Speak play URL\n * \n * @example\n * // Input: \"https://audio.3speak.tv/play?a=username/abc123\"\n * // Output: \"abc123\"\n */\nexport function extractAudioIdFromPlayUrl(playUrl: string): string | null {\n    try {\n        const url = new URL(playUrl);\n        const audioParam = url.searchParams.get('a');\n        if (audioParam) {\n            const parts = audioParam.split('/');\n            return parts[1] ?? null;\n        }\n        return null;\n    } catch {\n        return null;\n    }\n}\n\n/**\n * Record audio from microphone (browser only)\n * \n * @param options - Recording options\n * @returns Object with start, stop, and cancel methods\n */\nexport function createAudioRecorder(options?: {\n    /** Audio MIME type (default: 'audio/webm') */\n    mimeType?: string;\n    /** Callback when recording starts */\n    onStart?: () => void;\n    /** Callback with audio data chunks */\n    onDataAvailable?: (chunk: Blob) => void;\n    /** Callback when recording stops with final blob */\n    onStop?: (blob: Blob) => void;\n    /** Callback on error */\n    onError?: (error: Error) => void;\n}) {\n    let mediaRecorder: MediaRecorder | null = null;\n    let chunks: Blob[] = [];\n    let stream: MediaStream | null = null;\n    \n    return {\n        /**\n         * Start recording audio\n         */\n        async start(): Promise<void> {\n            try {\n                stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n                \n                const mimeType = options?.mimeType ?? 'audio/webm';\n                mediaRecorder = new MediaRecorder(stream, { mimeType });\n                chunks = [];\n                \n                mediaRecorder.ondataavailable = (event) => {\n                    if (event.data.size > 0) {\n                        chunks.push(event.data);\n                        options?.onDataAvailable?.(event.data);\n                    }\n                };\n                \n                mediaRecorder.onstop = () => {\n                    const blob = new Blob(chunks, { type: mimeType });\n                    options?.onStop?.(blob);\n                    \n                    // Clean up stream\n                    stream?.getTracks().forEach(track => track.stop());\n                    stream = null;\n                };\n                \n                mediaRecorder.onerror = () => {\n                    options?.onError?.(new Error('Recording failed'));\n                };\n                \n                mediaRecorder.start(1000); // Collect data every second\n                options?.onStart?.();\n            } catch (error) {\n                options?.onError?.(error instanceof Error ? error : new Error('Failed to start recording'));\n            }\n        },\n        \n        /**\n         * Stop recording and get the audio blob\n         */\n        stop(): void {\n            if (mediaRecorder && mediaRecorder.state !== 'inactive') {\n                mediaRecorder.stop();\n            }\n        },\n        \n        /**\n         * Cancel recording without saving\n         */\n        cancel(): void {\n            if (mediaRecorder && mediaRecorder.state !== 'inactive') {\n                mediaRecorder.stop();\n            }\n            chunks = [];\n            stream?.getTracks().forEach(track => track.stop());\n            stream = null;\n        },\n        \n        /**\n         * Check if currently recording\n         */\n        isRecording(): boolean {\n            return mediaRecorder?.state === 'recording';\n        }\n    };\n}\n"],"mappings":"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","names":[]}