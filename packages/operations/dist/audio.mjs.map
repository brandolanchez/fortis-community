{"version":3,"sources":["../src/audio.ts"],"sourcesContent":["/**\r\n * @snapie/operations/audio - Audio Upload Module\r\n * \r\n * Optional module for 3Speak audio upload integration.\r\n * Only import this if you need audio upload functionality.\r\n * \r\n * @example\r\n * ```typescript\r\n * import { uploadAudioTo3Speak } from '@snapie/operations/audio';\r\n * \r\n * const embedUrl = await uploadAudioTo3Speak(audioBlob, {\r\n *   apiKey: '...',\r\n *   owner: 'username',\r\n *   onProgress: (progress) => console.log(progress)\r\n * });\r\n * ```\r\n */\r\n\r\n/**\r\n * Audio upload progress callback\r\n */\r\nexport type AudioProgressCallback = (\r\n    progress: number,\r\n    status: 'uploading' | 'processing' | 'complete' | 'error'\r\n) => void;\r\n\r\n/**\r\n * Options for audio upload\r\n */\r\nexport interface AudioUploadOptions {\r\n    /** 3Speak API key */\r\n    apiKey: string;\r\n    /** Hive username of the uploader */\r\n    owner: string;\r\n    /** App name for metadata (default: \"snapie\") */\r\n    appName?: string;\r\n    /** Progress callback */\r\n    onProgress?: AudioProgressCallback;\r\n}\r\n\r\n/**\r\n * Audio upload result\r\n */\r\nexport interface AudioUploadResult {\r\n    /** The play URL to include in posts */\r\n    playUrl: string;\r\n    /** The audio ID */\r\n    audioId: string;\r\n}\r\n\r\n/**\r\n * Upload audio to 3Speak using TUS protocol\r\n * \r\n * @param file - Audio file or blob to upload\r\n * @param options - Upload options\r\n * @returns Promise resolving to play URL\r\n */\r\nexport async function uploadAudioTo3Speak(\r\n    file: File | Blob,\r\n    options: AudioUploadOptions\r\n): Promise<AudioUploadResult> {\r\n    // Dynamic import to avoid bundling tus-js-client when not needed\r\n    const tus = await import('tus-js-client');\r\n    \r\n    // Convert Blob to File if needed\r\n    const audioFile = file instanceof File \r\n        ? file \r\n        : new File([file], `audio-${Date.now()}.webm`, { type: file.type });\r\n    \r\n    return new Promise((resolve, reject) => {\r\n        let playUrl: string | null = null;\r\n        \r\n        const upload = new tus.Upload(audioFile, {\r\n            endpoint: 'https://audio.3speak.tv/uploads',\r\n            retryDelays: [0, 3000, 5000, 10000, 20000],\r\n            metadata: {\r\n                filename: audioFile.name,\r\n                owner: options.owner,\r\n                frontend_app: options.appName ?? 'snapie',\r\n                filetype: audioFile.type || 'audio/webm'\r\n            },\r\n            headers: {\r\n                'X-API-Key': options.apiKey\r\n            },\r\n            onError: (error) => {\r\n                options.onProgress?.(0, 'error');\r\n                reject(error);\r\n            },\r\n            onProgress: (bytesUploaded, bytesTotal) => {\r\n                const percentage = (bytesUploaded / bytesTotal) * 100;\r\n                options.onProgress?.(Math.round(percentage), 'uploading');\r\n            },\r\n            onAfterResponse: (req, res) => {\r\n                const url = res.getHeader('X-Play-URL');\r\n                if (url) {\r\n                    playUrl = url;\r\n                }\r\n            },\r\n            onSuccess: () => {\r\n                if (playUrl) {\r\n                    options.onProgress?.(100, 'complete');\r\n                    const audioId = extractAudioIdFromPlayUrl(playUrl);\r\n                    resolve({\r\n                        playUrl,\r\n                        audioId: audioId ?? ''\r\n                    });\r\n                } else {\r\n                    options.onProgress?.(0, 'error');\r\n                    reject(new Error('Failed to get play URL from server'));\r\n                }\r\n            }\r\n        });\r\n        \r\n        upload.start();\r\n    });\r\n}\r\n\r\n/**\r\n * Extract audio ID from 3Speak play URL\r\n * \r\n * @example\r\n * // Input: \"https://audio.3speak.tv/play?a=username/abc123\"\r\n * // Output: \"abc123\"\r\n */\r\nexport function extractAudioIdFromPlayUrl(playUrl: string): string | null {\r\n    try {\r\n        const url = new URL(playUrl);\r\n        const audioParam = url.searchParams.get('a');\r\n        if (audioParam) {\r\n            const parts = audioParam.split('/');\r\n            return parts[1] ?? null;\r\n        }\r\n        return null;\r\n    } catch {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Record audio from microphone (browser only)\r\n * \r\n * @param options - Recording options\r\n * @returns Object with start, stop, and cancel methods\r\n */\r\nexport function createAudioRecorder(options?: {\r\n    /** Audio MIME type (default: 'audio/webm') */\r\n    mimeType?: string;\r\n    /** Callback when recording starts */\r\n    onStart?: () => void;\r\n    /** Callback with audio data chunks */\r\n    onDataAvailable?: (chunk: Blob) => void;\r\n    /** Callback when recording stops with final blob */\r\n    onStop?: (blob: Blob) => void;\r\n    /** Callback on error */\r\n    onError?: (error: Error) => void;\r\n}) {\r\n    let mediaRecorder: MediaRecorder | null = null;\r\n    let chunks: Blob[] = [];\r\n    let stream: MediaStream | null = null;\r\n    \r\n    return {\r\n        /**\r\n         * Start recording audio\r\n         */\r\n        async start(): Promise<void> {\r\n            try {\r\n                stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n                \r\n                const mimeType = options?.mimeType ?? 'audio/webm';\r\n                mediaRecorder = new MediaRecorder(stream, { mimeType });\r\n                chunks = [];\r\n                \r\n                mediaRecorder.ondataavailable = (event) => {\r\n                    if (event.data.size > 0) {\r\n                        chunks.push(event.data);\r\n                        options?.onDataAvailable?.(event.data);\r\n                    }\r\n                };\r\n                \r\n                mediaRecorder.onstop = () => {\r\n                    const blob = new Blob(chunks, { type: mimeType });\r\n                    options?.onStop?.(blob);\r\n                    \r\n                    // Clean up stream\r\n                    stream?.getTracks().forEach(track => track.stop());\r\n                    stream = null;\r\n                };\r\n                \r\n                mediaRecorder.onerror = () => {\r\n                    options?.onError?.(new Error('Recording failed'));\r\n                };\r\n                \r\n                mediaRecorder.start(1000); // Collect data every second\r\n                options?.onStart?.();\r\n            } catch (error) {\r\n                options?.onError?.(error instanceof Error ? error : new Error('Failed to start recording'));\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Stop recording and get the audio blob\r\n         */\r\n        stop(): void {\r\n            if (mediaRecorder && mediaRecorder.state !== 'inactive') {\r\n                mediaRecorder.stop();\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Cancel recording without saving\r\n         */\r\n        cancel(): void {\r\n            if (mediaRecorder && mediaRecorder.state !== 'inactive') {\r\n                mediaRecorder.stop();\r\n            }\r\n            chunks = [];\r\n            stream?.getTracks().forEach(track => track.stop());\r\n            stream = null;\r\n        },\r\n        \r\n        /**\r\n         * Check if currently recording\r\n         */\r\n        isRecording(): boolean {\r\n            return mediaRecorder?.state === 'recording';\r\n        }\r\n    };\r\n}\r\n"],"mappings":"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","names":[]}